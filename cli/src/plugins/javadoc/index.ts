import { strict as assert } from "assert";
import execSh from "exec-sh";
import glob from "glob-promise";
import * as Path from "path";
import * as md from "mdast-builder";
import { promises as fs } from "fs";
import { cliSourceDirectory } from "../../cliSourceDirectory.js";
import { Plugin, PluginArgs } from "../../index.js";
import { ParsedClassDoc, ParsedPackageDoc } from "./doclet8.js";
import { Project } from "../../Project.js";
import { Node } from "../../mdast.js";
import { Page } from "../../Page.js";
import { tagsToMdast } from "./tagsToMdast.js";

const Javadoc: Plugin = {
  async run(args): Promise<void> {
    // 1. Run javadoc with JSON doclet to produce JSON files in temporary directory
    const { jsonPath } = await execJavadoc(args);
    // 2. Consume JSON files and produce Yokedox entities
    await processJson({ ...args, jsonPath });
  },
};

export default Javadoc;

type ExecJavadocResult = {
  jsonPath: string;
};

/**
  Executes javadoc in the shell with the JSON doclet.
 */
async function execJavadoc({
  generator,
  generatorArgs,
  tempDir,
}: PluginArgs): Promise<ExecJavadocResult> {
  const docletPath = Path.resolve(
    cliSourceDirectory,
    // TODO: Source from build directory
    "../../plugins/JsonDocletJava8/build/libs/JsonDocletJava8-all.jar"
  );

  const jsonPath = Path.resolve(tempDir, "javadoc");
  const commandLine = [
    generator,
    `-d '${jsonPath}'`,
    `-docletpath '${docletPath}'`,
    "-doclet com.yokedox.JsonDoclet8",
    ...generatorArgs,
  ].join(" ");

  try {
    await execSh.promise(commandLine);
  } catch (error) {
    console.error("Exit code:", error.code);
    // throw error;
  }
  return { jsonPath };
}

/**
  Process the JSON files generated by the doclet.
 */
async function processJson(
  args: PluginArgs & ExecJavadocResult
): Promise<void> {
  const { jsonPath, project } = args;
  // Glob files in jsonPath and open them
  const paths = await glob(Path.join(jsonPath, "/") + "**/*.json");
  const promises = paths.map(async (path) => {
    // Incoming data MUST conform to JSON schema
    // TODO: Could validate again here
    const data = JSON.parse(await fs.readFile(path, "utf8"));
    const { _class } = data;
    switch (_class) {
      case "ParsedClassDoc":
        return processClassDoc(project, data as ParsedClassDoc);
      case "ParsedPackageDoc":
        return processPackageDoc(project, data as ParsedPackageDoc);
      default:
        throw new Error(`Unexpected _class type: ${_class}`);
    }
  });
  await Promise.all(promises);
  await project.finalize();
}

async function processClassDoc(
  project: Project,
  doc: ParsedClassDoc
): Promise<void> {
  const root = md.root(
    makeSection({
      project,
      doc,
      depth: 1,
      title: md.text(doc.asString),
      makeBody: makeClassDocPageBody,
    })
  );
  const path = `/${doc.asString}`;
  project.writePage(new Page(path, root));
}

async function processPackageDoc(
  project: Project,
  doc: ParsedPackageDoc
): Promise<void> {
  // TODO
}

function makeTable(labels: string[], rows: (Node | Node[])[][]) {
  return md.table(
    Array(labels.length).map(() => "left"),
    [
      md.tableRow(labels.map((label) => md.tableCell([md.text(label)]))),
      ...rows.map((row) => {
        assert(
          row.length === labels.length,
          "expected row and label length to match"
        );
        return md.tableRow(row.map((cell) => md.tableCell(cell)));
      }),
    ]
  );
}

function makeSuperclassList(project: Project, doc: ParsedClassDoc) {
  const { superclassType } = doc;
  if (superclassType == null) {
    return [];
  }

  const { qualifiedTypeName } = superclassType;
  return [
    md.paragraph(md.emphasis(md.text("Superclass:"))),
    md.list("unordered", [
      md.listItem(
        project.makeInternalLink(qualifiedTypeName, qualifiedTypeName, [
          md.text(qualifiedTypeName),
        ])
      ),
    ]),
  ];
}

function makeImplementedInterfacesList(project: Project, doc: ParsedClassDoc) {
  const { interfaceTypes } = doc;
  if (interfaceTypes.length === 0) {
    return [];
  }
  return [
    md.paragraph(md.emphasis(md.text("Implemented interfaces:"))),
    md.list(
      "unordered",
      interfaceTypes.map(({ qualifiedTypeName }) =>
        md.listItem(
          project.makeInternalLink(qualifiedTypeName, qualifiedTypeName, [
            md.text(qualifiedTypeName),
          ])
        )
      )
    ),
  ];
}

type MakeSectionArgs = {
  project: Project;
  doc: ParsedClassDoc;
  title: string | Node | Node[];
  depth: number;
  shouldMakeSection?(args: MakeSectionArgs): boolean;
  makeBody(args: MakeSectionArgs): Node[] | Node;
};

function makeSection(args: MakeSectionArgs): Node[] {
  const { shouldMakeSection, depth, title, makeBody } = args;
  if (shouldMakeSection !== undefined && !shouldMakeSection(args)) {
    return [];
  }
  return [
    md.heading(depth, typeof title === "string" ? md.text(title) : title),
    ...[makeBody(args)].flat(1),
  ];
}

function makeClassDocPageBody(args: MakeSectionArgs): Node[] {
  const { project, doc } = args;
  const depth = args.depth + 1;
  return [
    // Class hierarchy
    ...makeSuperclassList(project, doc),

    // Implemented interfaces
    ...makeImplementedInterfacesList(project, doc),

    // Comment body
    tagsToMdast(project, doc.inlineTags),

    ...makeSection({
      project,
      doc,
      depth,
      title: "Constructors",
      shouldMakeSection: () => doc.constructors.length !== 0,
      makeBody: () =>
        md.list(
          "unordered",
          doc.constructors.map((doc) =>
            md.listItem([
              md.text(doc.qualifiedName),
              md.text(doc.flatSignature),
            ])
          )
        ),
    }),

    ...makeSection({
      project,
      doc,
      depth,
      title: "Nested Class Summary",
      shouldMakeSection: () => doc.innerClasses.length !== 0,
      makeBody: () =>
        makeTable(
          ["Modifier and Type", "Class and Description"],
          doc.innerClasses.map((classDoc) => [
            md.text(classDoc.modifiers ?? ""),
            md.text(classDoc.qualifiedTypeName), // TODO: Must fetch complete classDoc from another file
          ])
        ),
    }),

    ...makeSection({
      project,
      doc,
      depth,
      title: "Field Summary",
      shouldMakeSection: () => doc.fields.length !== 0,
      makeBody: () =>
        makeTable(
          ["Modifier and Type", "Field and Description"],
          doc.fields.map((fieldDoc) => [
            md.paragraph([
              md.text(fieldDoc.modifiers),
              md.text(" "),
              md.text(fieldDoc.type.asString),
            ]),
            [
              md.paragraph(md.text(fieldDoc.name)),
              md.text(fieldDoc.commentText),
            ],
          ])
        ),
    }),

    ...makeSection({
      project,
      doc,
      depth,
      title: "Method Summary",
      shouldMakeSection: () => doc.methods.length !== 0,
      makeBody: () =>
        makeTable(
          ["Modifier and Type", "Method and Description"],
          doc.methods.map((doc) => [
            [md.text(doc.modifiers), md.text(doc.returnType.typeName)],
            [
              md.paragraph(
                project.makeInternalLink(`#${doc.name}`, `#${doc.name}`, [
                  md.text(doc.name),
                  md.text("("),
                  ...doc.parameters
                    .map((parameter, i) => [
                      md.text(parameter.asString),
                      i === doc.parameters.length - 1
                        ? md.text("")
                        : md.text(", "),
                    ])
                    .flat(1),
                  md.text(")\n\n"),
                ])
              ),
              md.paragraph(tagsToMdast(project, doc.firstSentenceTags)),
            ],
          ])
        ),
    }),

    ...makeSection({
      project,
      doc,
      depth,
      title: "Field Detail",
      shouldMakeSection: () => doc.fields.length !== 0,
      makeBody: () =>
        doc.fields
          .map((doc) => [
            project.makeAnchor(`${doc.name}${doc.name.replace(/\s/g, "")}`),
            md.heading(3, md.text(doc.name)),
            tagsToMdast(project, doc.inlineTags),
          ])
          .flat(1),
    }),

    ...makeSection({
      project,
      doc,
      depth,
      title: "Method Detail",
      shouldMakeSection: () => doc.methods.length !== 0,
      makeBody: () =>
        doc.methods
          .map((doc) => [
            project.makeAnchor(
              `${doc.name}${doc.flatSignature.replace(/\s/g, "")}`
            ),
            md.heading(3, md.text(doc.name)),
            tagsToMdast(project, doc.inlineTags),
          ])
          .flat(1),
    }),
  ];
}
