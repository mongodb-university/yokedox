import { strict as assert } from "assert";
import execSh from "exec-sh";
import { promises as fs } from "fs";
import glob from "glob-promise";
import * as md from "mdast-builder";
import * as Path from "path";
import { cliSourceDirectory } from "../../cliSourceDirectory.js";
import { Plugin, PluginArgs } from "../../index.js";
import { Page } from "../../Page.js";
import { Project } from "../../Project.js";
import { Node } from "../../yokedast.js";
import { buildIndexes } from "./buildIndexes.js";
import { MethodDoc, ParsedClassDoc, ParsedPackageDoc } from "./doclet8.js";
import { tagsToMdast } from "./tagsToYokedast.js";

export type JavadocEntityData = {
  category: "class" | "package";
};

const Javadoc: Plugin<JavadocEntityData> = {
  async run(args): Promise<void> {
    // 1. Run javadoc with JSON doclet to produce JSON files in temporary directory
    const { jsonPath } = await execJavadoc(args);
    // 2. Consume JSON files and produce Yokedox entities
    await processJson({ ...args, jsonPath });
    // 3. Build indexes and additional pages
    const finalizedProject = await args.project.finalize();
    await buildIndexes({ finalizedProject });
  },
};

export default Javadoc;

type ExecJavadocResult = {
  jsonPath: string;
};

/**
  Executes javadoc in the shell with the JSON doclet.
 */
async function execJavadoc({
  generator,
  generatorArgs,
  tempDir,
}: PluginArgs<JavadocEntityData>): Promise<ExecJavadocResult> {
  const docletPath = Path.resolve(
    cliSourceDirectory,
    // TODO: Source from build directory
    "../../plugins/JsonDocletJava8/build/libs/JsonDocletJava8-all.jar"
  );

  const jsonPath = Path.resolve(tempDir, "javadoc");
  const commandLine = [
    generator,
    `-d '${jsonPath}'`,
    `-docletpath '${docletPath}'`,
    "-doclet com.yokedox.JsonDoclet8",
    ...generatorArgs,
  ].join(" ");

  try {
    await execSh.promise(commandLine);
  } catch (error) {
    console.error("Exit code:", error.code);
    // throw error;
  }
  return { jsonPath };
}

/**
  Process the JSON files generated by the doclet.
 */
async function processJson(
  args: PluginArgs<JavadocEntityData> & ExecJavadocResult
): Promise<void> {
  const { jsonPath, project } = args;
  // Glob files in jsonPath and open them
  const paths = await glob(Path.join(jsonPath, "/") + "**/*.json");
  const promises = paths.map(async (path) => {
    // Incoming data MUST conform to JSON schema
    // TODO: Could validate again here
    const data = JSON.parse(await fs.readFile(path, "utf8"));
    const { _class } = data;
    switch (_class) {
      case "ParsedClassDoc":
        return processClassDoc(project, data as ParsedClassDoc);
      case "ParsedPackageDoc":
        return processPackageDoc(project, data as ParsedPackageDoc);
      default:
        throw new Error(`Unexpected _class type: ${_class}`);
    }
  });
  await Promise.all(promises);
}

async function processClassDoc(
  project: Project<JavadocEntityData>,
  doc: ParsedClassDoc
): Promise<void> {
  const pageUri = `/${doc.qualifiedTypeName}`;
  const root = md.root(
    makeSection({
      project,
      pageUri,
      doc,
      depth: 1,
      title: md.text(doc.asString),
      makeBody: makeClassDocPageBody,
    })
  );
  project.writePage(new Page(pageUri, root));
}

async function processPackageDoc(
  project: Project<JavadocEntityData>,
  doc: ParsedPackageDoc
): Promise<void> {
  // TODO
}

function makeTable(labels: string[], rows: (Node | Node[])[][]) {
  return md.table(
    Array(labels.length).map(() => "left"),
    [
      md.tableRow(labels.map((label) => md.tableCell([md.text(label)]))),
      ...rows.map((row) => {
        assert(
          row.length === labels.length,
          "expected row and label length to match"
        );
        return md.tableRow(row.map((cell) => md.tableCell(cell)));
      }),
    ]
  );
}

function makeSuperclassList(project: Project, doc: ParsedClassDoc) {
  const { superclassType } = doc;
  if (superclassType == null) {
    return [];
  }

  const { qualifiedTypeName } = superclassType;
  return [
    md.paragraph(md.emphasis(md.text("Superclass:"))),
    md.list("unordered", [
      md.listItem(project.linkToEntity(qualifiedTypeName)),
    ]),
  ];
}

function makeImplementedInterfacesList(project: Project, doc: ParsedClassDoc) {
  const { interfaceTypes } = doc;
  if (interfaceTypes.length === 0) {
    return [];
  }
  return [
    md.paragraph(md.emphasis(md.text("Implemented interfaces:"))),
    md.list(
      "unordered",
      interfaceTypes.map(({ qualifiedTypeName }) =>
        md.listItem(project.linkToEntity(qualifiedTypeName))
      )
    ),
  ];
}

type MakeSectionArgs = {
  project: Project<JavadocEntityData>;
  pageUri: string;
  doc: ParsedClassDoc;
  title: string | Node | Node[];
  depth: number;
  shouldMakeSection?(args: MakeSectionArgs): boolean;
  makeBody(args: MakeSectionArgs): Node[] | Node;
};

function makeSection(args: MakeSectionArgs): Node[] {
  const { shouldMakeSection, depth, title, makeBody } = args;
  if (shouldMakeSection !== undefined && !shouldMakeSection(args)) {
    return [];
  }
  return [
    md.heading(depth, typeof title === "string" ? md.text(title) : title),
    ...[makeBody(args)].flat(1),
  ];
}

function makeClassDocPageBody(args: MakeSectionArgs): Node[] {
  const { project, doc, pageUri } = args;
  const depth = args.depth + 1;
  return [
    // Declare the class itself as an entity
    project.declareEntity({
      canonicalName: doc.qualifiedTypeName,
      pageUri,
      data: {
        category: "class",
      },
    }),

    // Class hierarchy
    ...makeSuperclassList(project, doc),

    // Implemented interfaces
    ...makeImplementedInterfacesList(project, doc),

    // Comment body
    tagsToMdast(project, doc.inlineTags),

    ...makeSection({
      ...args,
      depth,
      title: "Constructors",
      shouldMakeSection: () => doc.constructors.length !== 0,
      makeBody: () =>
        md.list(
          "unordered",
          doc.constructors.map((doc) =>
            md.listItem([
              md.text(doc.qualifiedName),
              md.text(doc.flatSignature),
            ])
          )
        ),
    }),

    ...makeSection({
      ...args,
      depth,
      title: "Nested Class Summary",
      shouldMakeSection: () => doc.innerClasses.length !== 0,
      makeBody: () =>
        makeTable(
          ["Modifier and Type", "Class and Description"],
          doc.innerClasses.map((classDoc) => [
            md.text(classDoc.modifiers ?? ""),
            md.text(classDoc.qualifiedTypeName), // TODO: Must fetch complete classDoc from another file
          ])
        ),
    }),

    ...makeSection({
      ...args,
      depth,
      title: "Field Summary",
      shouldMakeSection: () => doc.fields.length !== 0,
      makeBody: () =>
        makeTable(
          ["Modifier and Type", "Field and Description"],
          doc.fields.map((fieldDoc) => [
            md.paragraph([
              md.text(fieldDoc.modifiers),
              md.text(" "),
              md.text(fieldDoc.type.asString),
            ]),
            [
              md.paragraph(md.text(fieldDoc.name)),
              md.text(fieldDoc.commentText),
            ],
          ])
        ),
    }),

    ...makeSection({
      ...args,
      depth,
      title: "Method Summary",
      shouldMakeSection: () => doc.methods.length !== 0,
      makeBody: () =>
        makeTable(
          ["Modifier and Type", "Method and Description"],
          doc.methods.map((doc) => [
            [
              md.text(doc.modifiers),
              md.text(" "),
              project.linkToEntity(
                doc.returnType.qualifiedTypeName,
                doc.returnType.typeName
              ),
            ],
            [
              md.paragraph([
                project.linkToEntity(getCanonicalNameForMethod(doc), doc.name),
                md.text(" "),
                ...makeTypeParameterListWithLinks(project, doc),
                ...makeParameterListWithLinks(project, doc),
              ]),
              md.paragraph(tagsToMdast(project, doc.firstSentenceTags)),
            ],
          ])
        ),
    }),

    ...makeSection({
      ...args,
      depth,
      title: "Field Detail",
      shouldMakeSection: () => doc.fields.length !== 0,
      makeBody: () =>
        doc.fields
          .map((doc) => [
            project.declareEntity({
              canonicalName: doc.qualifiedName,
              pageUri,
            }),
            md.heading(3, md.text(doc.name)),
            tagsToMdast(project, doc.inlineTags),
          ])
          .flat(1),
    }),

    ...makeSection({
      ...args,
      depth,
      title: "Method Detail",
      shouldMakeSection: () => doc.methods.length !== 0,
      makeBody: ({ depth }) =>
        doc.methods
          .map((doc) => {
            const canonicalName = getCanonicalNameForMethod(doc);
            return [
              project.declareEntity({
                canonicalName,
                pageUri,
              }),
              md.heading(depth + 1, md.text(doc.name)),
              md.paragraph([
                md.text(doc.modifiers),
                md.text(" "),
                project.linkToEntity(
                  doc.returnType.qualifiedTypeName,
                  doc.returnType.typeName
                ),
                md.text(` ${doc.name} `),
                ...makeTypeParameterListWithLinks(project, doc),
                ...makeParameterListWithLinks(project, doc),
              ]),
              tagsToMdast(project, doc.inlineTags),
              ...makeSection({
                ...args,
                depth: depth + 1,
                title: "Parameters",
                shouldMakeSection: () => doc.paramTags.length !== 0,
                makeBody: () => {
                  return md.list(
                    "unordered",
                    doc.paramTags.map((paramTag) => {
                      return md.listItem([
                        md.text(`${paramTag.name} - `),
                        tagsToMdast(project, paramTag.inlineTags ?? []),
                      ]);
                    })
                  );
                },
              }),
            ];
          })
          .flat(1),
    }),
  ];
}

const getCanonicalNameForMethod = (doc: MethodDoc): string => {
  return `${doc.qualifiedName}(${doc.flatSignature})`;
};

const makeParameterListWithLinks = (
  project: Project<JavadocEntityData>,
  doc: MethodDoc
): Node[] => {
  return [
    md.text("("),
    ...doc.parameters
      .map((parameter, i) => [
        project.linkToEntity(
          parameter.type.qualifiedTypeName,
          parameter.typeName
        ),
        md.text(
          ` ${parameter.name ?? ""}${i < doc.parameters.length - 1 ? ", " : ""}`
        ),
      ])
      .flat(1),
    md.text(")"),
  ];
};

const makeTypeParameterListWithLinks = (
  project: Project<JavadocEntityData>,
  doc: MethodDoc
): Node[] => {
  if (doc.typeParameters.length === 0) {
    return [];
  }
  return [
    md.text("<"),
    ...doc.typeParameters
      .map((parameter, i) => [
        project.linkToEntity(parameter.qualifiedTypeName, parameter.typeName),
        md.text(
          ` ${parameter.name ?? ""}${
            i < doc.typeParameters.length - 1 ? ", " : ""
          }`
        ),
      ])
      .flat(1),
    md.text(">"),
  ];
};
